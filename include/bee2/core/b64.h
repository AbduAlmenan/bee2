/*
*******************************************************************************
\file hex.h
\brief Base64 encoding
\project bee2 [cryptographic library]
\author (C) Sergey Agievich [agievich@{bsu.by|gmail.com}]
\created 2016.06.16
\version 2016.06.16
\license This program is released under the GNU General Public License 
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

/*!
*******************************************************************************
\file b64.h
\brief Кодирование base64
*******************************************************************************
*/

#ifndef __BEE2_B64_H
#define __BEE2_B64_H

#include "bee2/defs.h"
#include "bee2/core/safe.h"

#ifdef __cplusplus
extern "C" {
#endif

/*!
*******************************************************************************
\file b64.h

Реализовано кодирование буферов памяти base64-строками по правилам RFC 4848.
Base64-строка -- это слово в алфавите 
	enc_table = {'A',...,'F','a',...,'f','0',...,'9','+','/'},
которое может дополняться одним или двумя символами '=' и длина которого всегда 
кратна 4.

Правила кодирования:
1 Кодируемые данные разбиваются на блоки --- тройки октетов или 24-ки битов. 
  Каждая 24-ка рабивается на четыре 6-ки битов. Каждая 6-ка битов кодируется 
  символом таблицы enc_table.
2 Если последний блок данных является неполным, то  он дополняется до полного 
  8 или 16 нулевыми битами, а затем кодируется 3 или 2 символами алфавита 
  enc_table. 
3 Более точно, если блок дополняется 8 нулеаыми битами, то кодируются первые 
  18 = 6 * 3 битов блока (16 значащих и 2 дописанных нуля). 
  Если блок дополняется 16  нулевыми битами, то кодируются первые 12 = 6 * 2 
  битов (8 значащих и 4 служебных нуля).
4 Полученное кодовое слово дополняется символами '=' до тех пор, пока его 
  длина не станет кратной 4.

\pre Во все функции, кроме вомзожно b64IsValid(), передаются корректные 
строки и буферы памяти.
*******************************************************************************
*/

/*!	\brief Корректная base64-строка?

	Проверяется корректность base64-строки b64. Строка считается корректной, 
	если:
	- длина строки кратна 4;
	- строка может заканчиваться 1 или 2 символами '=', все остальные символы
	  принадлежат алфавиту enc_table;
    - если последний блок строки имеет вид abc=, то в 6-кe битов, 
	  соответствующих символу c, два младших  бита нулевые;
    - если последний блок строки имеет вид ab==, то в 6-кe битов, 
	  соответствующих символу b, четыре младших бита нулевые.
	\return Признак корректности.
	\safe Функция нерегулярна.
*/
bool_t b64IsValid(
	const char* b64		/*!< [in] base64-строка */
);

/*!	\brief Кодирование буфера памяти

	Буфер [count]src кодируется base64-строкой [4 * ((count + 2) / 3) + 1]dest.
	\pre Буферы dest и src не пересекаются.
*/
void b64From(
	char* dest,			/*!< [out] строка-приемник */
	const void* src,	/*!< [in] память-источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Декодирование буфера памяти

	Base64-строка src декодируется в строку октетов [?count]dest.
	\pre Если dest != 0, то буфер [count]dest корректен и его размер
	достаточен для размещения декодированных данных.
	\pre Буферы dest и src не пересекаются.
	\pre b64IsValid(src) == TRUE. 
	\remark Достаточный объем dest -- 3 * strLen(src) / 4 октетов.
*/
void b64To(
	void* dest,			/*!< [out] память-приемник */
	size_t* count,		/*!< [in/out] размер буфера dest */
	const char* src		/*!< [in] строка-источник */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_B64_H */
